generator client {
    provider = "prisma-client-js"
    binaryTargets = ["native", "linux-musl-arm64-openssl-3.0.x"]
    output = "/home/ubuntu/audience_response_system/app/node_modules/.prisma/client"
}

datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL")
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model User {
  id               String                @id @default(cuid())
  name             String?
  email            String?               @unique
  emailVerified    DateTime?
  image            String?
  role             UserRole              @default(PARTICIPANT)
  password         String?
  accounts         Account[]
  sessions         Session[]
  pollingSessions  PollingSession[]
  responses        Response[]
  participations   SessionParticipant[]
  createdAt        DateTime              @default(now())
  updatedAt        DateTime              @updatedAt
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// Main polling session model
model PollingSession {
  id                    String               @id @default(cuid())
  title                 String
  description           String?
  sessionCode           String               @unique
  adminId               String
  status                SessionStatus        @default(WAITING)
  allowAnonymous        Boolean              @default(true)
  showRealTimeResults   Boolean              @default(false)
  maxParticipants       Int?
  createdAt             DateTime             @default(now())
  updatedAt             DateTime             @updatedAt
  admin                 User                 @relation(fields: [adminId], references: [id], onDelete: Cascade)
  questions             Question[]
  participants          SessionParticipant[]
  responses             Response[]

  @@index([sessionCode])
}

// Track participants in each session
model SessionParticipant {
  id        String         @id @default(cuid())
  sessionId String
  userId    String?
  nickname  String?
  joinedAt  DateTime       @default(now())
  session   PollingSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  user      User?          @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@unique([sessionId, userId])
  @@unique([sessionId, nickname])
}

// Questions in polling sessions
model Question {
  id          String         @id @default(cuid())
  sessionId   String
  title       String
  description String?
  type        QuestionType
  options     String[]       @default([]) // For multiple choice questions
  required    Boolean        @default(true)
  active      Boolean        @default(false)
  order       Int            @default(0)
  timeLimit   Int? // in seconds
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt
  session     PollingSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  responses   Response[]

  @@index([sessionId, order])
}

// Response to questions
model Response {
  id           String         @id @default(cuid())
  questionId   String
  sessionId    String
  userId       String?
  participantId String?
  responseType ResponseType
  textValue    String?
  optionValue  String?
  fileUrl      String?
  submittedAt  DateTime       @default(now())
  question     Question       @relation(fields: [questionId], references: [id], onDelete: Cascade)
  session      PollingSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  user         User?          @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([questionId])
  @@index([sessionId])
}

// File uploads for photo submissions
model Upload {
  id          String   @id @default(cuid())
  filename    String
  originalName String
  mimeType    String
  fileSize    Int
  fileUrl     String
  uploadedAt  DateTime @default(now())

  @@index([filename])
}

enum UserRole {
  ADMIN
  PARTICIPANT
}

enum SessionStatus {
  WAITING
  ACTIVE
  PAUSED
  COMPLETED
}

enum QuestionType {
  MULTIPLE_CHOICE
  TEXT
  PHOTO_UPLOAD
  RATING
  POLL
}

enum ResponseType {
  TEXT
  OPTION
  FILE
  RATING
}
